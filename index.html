<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>0500</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
</head>
<body>
<script>
// ═══════════════════════════════════════════════════════════════════════════════
// CONFIGURATION — Edit this section to customize your dashboard
// ═══════════════════════════════════════════════════════════════════════════════

const CONFIG = {
    // Your location (for globe marker)
    location: {
        lat: 42.98,
        lon: -81.25,
        name: "London, ON"
    },

    // Daily intentions — reset these each morning
    daily: [
        "Morning workout",
        "Review lecture notes",
        "Work on project proposal",
        "Call mom",
        "Read for 30 minutes"
    ],

    // Mid-term goals — weeks to months
    midTerm: [
        "Finish capstone project",
        "Prepare for finals",
        "Update resume"
    ],

    // Long-term goals — months to years
    longTerm: [
        "Graduate with honors",
        "Land dream job",
        "Build personal project portfolio"
    ],

    // Today's schedule
    // type: "work" | "school" | "physical"
    schedule: [
        { time: "06:00", duration: 60, title: "Morning Workout", type: "physical" },
        { time: "08:00", duration: 30, title: "Breakfast & Review", type: "work" },
        { time: "09:00", duration: 90, title: "ECE 101 Lecture", type: "school" },
        { time: "11:00", duration: 60, title: "Study Session", type: "school" },
        { time: "12:00", duration: 60, title: "Lunch Break", type: "physical" },
        { time: "13:00", duration: 120, title: "Project Work", type: "work" },
        { time: "15:30", duration: 90, title: "ECE 202 Lab", type: "school" },
        { time: "17:30", duration: 60, title: "Gym", type: "physical" },
        { time: "19:00", duration: 60, title: "Dinner", type: "physical" },
        { time: "20:00", duration: 120, title: "Evening Study", type: "school" }
    ],

    // Timer presets in minutes
    timerPresets: [5, 10, 15, 25]
};

// ═══════════════════════════════════════════════════════════════════════════════
// END CONFIGURATION
// ═══════════════════════════════════════════════════════════════════════════════
</script>

<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --orange-100: #fff7ed;
    --orange-200: #ffedd5;
    --orange-300: #fdba74;
    --orange-400: #fb923c;
    --orange-500: #f97316;
    --coral: #ff7f6e;
    --peach: #ffb59a;
    --pink: #ffc4d0;
    --warm-purple: #e8b4c8;
    --teal: #5eadb0;
    --teal-soft: #7ec8ca;
    --warm-grey: #b8a89a;
    --amber: #d4a574;
    --text-primary: #1a1a1a;
    --text-secondary: #4a4a4a;
    --text-muted: #7a7a7a;
    --check-green: #6ab04c;
}

html, body {
    height: 100%;
    overflow: hidden;
    font-family: 'Inter', -apple-system, sans-serif;
    color: var(--text-primary);
}

/* Lava lamp background */
.background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -2;
    background: linear-gradient(180deg, #ffd4b8 0%, #ffc9a8 50%, #ffbe98 100%);
}

#lava-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
}

/* Main layout */
.dashboard {
    height: 100vh;
    display: flex;
    flex-direction: column;
    padding: 2rem 3rem;
    opacity: 1;
    transition: opacity 0.5s ease;
}

.dashboard.hidden {
    opacity: 0;
    pointer-events: none;
}

/* Clock */
.clock-container {
    text-align: center;
    padding: 0.5rem 0 1.5rem;
}

.clock {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 7rem;
    font-weight: 400;
    letter-spacing: 0.02em;
    color: var(--text-primary);
    line-height: 1;
}

.clock-period {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 2rem;
    font-weight: 400;
    margin-left: 0.25rem;
    opacity: 0.7;
    vertical-align: super;
}

/* Main content area */
.main-content {
    flex: 1;
    display: grid;
    grid-template-columns: 260px 1fr 240px;
    gap: 2.5rem;
    min-height: 0;
}

/* Goals section */
.goals-section {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
    overflow-y: auto;
    padding-right: 0.5rem;
}

.goals-section::-webkit-scrollbar {
    width: 3px;
}

.goals-section::-webkit-scrollbar-track {
    background: transparent;
}

.goals-section::-webkit-scrollbar-thumb {
    background: var(--orange-300);
    border-radius: 2px;
}

.goal-group {
    background: rgba(255, 255, 255, 0.4);
    backdrop-filter: blur(10px);
    border-radius: 14px;
    padding: 1rem 1.25rem;
}

.goal-group h3 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 0.9rem;
    font-weight: 400;
    letter-spacing: 0.08em;
    color: var(--text-secondary);
    margin-bottom: 0.75rem;
}

.goal-item {
    display: flex;
    align-items: center;
    gap: 0.7rem;
    padding: 0.4rem 0;
    cursor: pointer;
    transition: opacity 0.3s ease;
}

.goal-item.checked {
    opacity: 0.35;
}

.goal-checkbox {
    width: 16px;
    height: 16px;
    border: 2px solid var(--text-muted);
    border-radius: 50%;
    flex-shrink: 0;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.goal-item.checked .goal-checkbox {
    background: var(--check-green);
    border-color: var(--check-green);
}

.goal-checkbox::after {
    content: '';
    width: 5px;
    height: 5px;
    background: white;
    border-radius: 50%;
    opacity: 0;
    transform: scale(0);
    transition: all 0.2s ease;
}

.goal-item.checked .goal-checkbox::after {
    opacity: 1;
    transform: scale(1);
}

.goal-text {
    font-size: 0.85rem;
    font-weight: 400;
    color: var(--text-primary);
    line-height: 1.35;
}

/* Globe section */
.globe-section {
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

#globe-canvas {
    max-width: 100%;
    max-height: 100%;
}

.globe-loading {
    position: absolute;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1rem;
    color: var(--text-muted);
    letter-spacing: 0.1em;
}

/* Schedule section */
.schedule-section {
    background: rgba(255, 255, 255, 0.35);
    backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 1rem;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.schedule-header {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 0.9rem;
    font-weight: 400;
    letter-spacing: 0.08em;
    color: var(--text-secondary);
    margin-bottom: 0.6rem;
    padding: 0 0.5rem;
}

.schedule-scroll {
    flex: 1;
    overflow-y: auto;
    position: relative;
}

.schedule-scroll::-webkit-scrollbar {
    width: 3px;
}

.schedule-scroll::-webkit-scrollbar-track {
    background: transparent;
}

.schedule-scroll::-webkit-scrollbar-thumb {
    background: var(--orange-300);
    border-radius: 2px;
}

.time-grid {
    position: relative;
    min-height: 100%;
}

.time-slot {
    height: 20px;
    display: flex;
    align-items: flex-start;
    position: relative;
}

.time-label {
    font-family: 'Inter', sans-serif;
    font-size: 0.6rem;
    font-weight: 500;
    color: var(--text-muted);
    width: 40px;
    flex-shrink: 0;
}

.time-line {
    flex: 1;
    height: 1px;
    background: var(--text-muted);
    opacity: 0.12;
    margin-top: 0.45rem;
}

.schedule-events {
    position: absolute;
    top: 0;
    left: 44px;
    right: 4px;
    height: 100%;
    pointer-events: none;
}

.schedule-event {
    position: absolute;
    left: 0;
    right: 0;
    border-radius: 6px;
    padding: 0.35rem 0.5rem;
    font-family: 'Inter', sans-serif;
    font-size: 0.7rem;
    font-weight: 500;
    color: white;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    pointer-events: auto;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}

.schedule-event.physical {
    background: linear-gradient(135deg, var(--orange-400), var(--coral));
}

.schedule-event.school {
    background: linear-gradient(135deg, var(--teal), var(--teal-soft));
}

.schedule-event.work {
    background: linear-gradient(135deg, var(--warm-grey), var(--amber));
}

/* Timer section */
.timer-bar {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0.8rem;
    padding: 1.25rem 0 0.5rem;
}

.timer-preset {
    width: 44px;
    height: 44px;
    border: none;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.45);
    backdrop-filter: blur(10px);
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.1rem;
    font-weight: 400;
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.3s ease;
}

.timer-preset:hover {
    background: rgba(255, 255, 255, 0.65);
    transform: scale(1.08);
}

/* Timer fullscreen overlay */
.timer-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
        135deg,
        #ff8c5a 0%,
        #ffa07a 25%,
        #ffb899 50%,
        #ffd0b8 75%,
        #ffe8d8 100%
    );
    background-size: 400% 400%;
    animation: gradientShift 20s ease infinite;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
}

.timer-overlay.active {
    opacity: 1;
    pointer-events: auto;
}

.timer-display {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 18rem;
    font-weight: 400;
    color: var(--text-primary);
    letter-spacing: 0.02em;
    line-height: 1;
}

.timer-label {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.2rem;
    font-weight: 400;
    letter-spacing: 0.15em;
    color: var(--text-secondary);
    margin-top: 0.5rem;
}

.timer-controls {
    display: flex;
    gap: 1.5rem;
    margin-top: 2.5rem;
}

.timer-btn {
    padding: 0.9rem 2.2rem;
    border: none;
    border-radius: 25px;
    background: rgba(255, 255, 255, 0.45);
    backdrop-filter: blur(10px);
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1rem;
    font-weight: 400;
    letter-spacing: 0.05em;
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.3s ease;
}

.timer-btn:hover {
    background: rgba(255, 255, 255, 0.65);
    transform: scale(1.05);
}

.timer-btn.stop {
    background: rgba(255, 100, 100, 0.35);
}

.timer-btn.stop:hover {
    background: rgba(255, 100, 100, 0.55);
}

/* Timer globe background */
.timer-globe {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    opacity: 0.1;
    z-index: -1;
}

/* Responsive */
@media (max-width: 1200px) {
    .main-content {
        grid-template-columns: 220px 1fr 200px;
        gap: 2rem;
    }

    .clock {
        font-size: 5.5rem;
    }
}

@media (max-width: 900px) {
    .main-content {
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto 1fr;
    }

    .globe-section {
        grid-column: 1 / -1;
        height: 250px;
    }
}
</style>

<div class="background"></div>
<canvas id="lava-canvas"></canvas>

<div class="dashboard" id="dashboard">
    <div class="clock-container">
        <span class="clock" id="clock">5:00</span>
        <span class="clock-period" id="clock-period">AM</span>
    </div>

    <div class="main-content">
        <div class="goals-section" id="goals-section">
            <!-- Goals populated by JS -->
        </div>

        <div class="globe-section">
            <div class="globe-loading" id="globe-loading">LOADING...</div>
            <canvas id="globe-canvas"></canvas>
        </div>

        <div class="schedule-section">
            <div class="schedule-header">TODAY</div>
            <div class="schedule-scroll" id="schedule-scroll">
                <div class="time-grid" id="time-grid">
                    <!-- Time slots populated by JS -->
                </div>
                <div class="schedule-events" id="schedule-events">
                    <!-- Events populated by JS -->
                </div>
            </div>
        </div>
    </div>

    <div class="timer-bar" id="timer-bar">
        <!-- Timer presets populated by JS -->
    </div>
</div>

<div class="timer-overlay" id="timer-overlay">
    <canvas class="timer-globe" id="timer-globe-canvas"></canvas>
    <div class="timer-display" id="timer-display">25:00</div>
    <div class="timer-label">FOCUS TIME</div>
    <div class="timer-controls">
        <button class="timer-btn" id="timer-pause">PAUSE</button>
        <button class="timer-btn stop" id="timer-stop">END</button>
    </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════════════
// LAVA LAMP BACKGROUND
// ═══════════════════════════════════════════════════════════════════════════════

class LavaLamp {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.blobs = [];
        this.time = 0;
        this.numBlobs = 8;

        // Narrow warm palette - similar hues for seamless blending
        this.colors = [
            { h: 20, s: 70, l: 65 },    // Soft orange
            { h: 25, s: 65, l: 68 },    // Light amber
            { h: 18, s: 60, l: 70 },    // Peach
            { h: 28, s: 70, l: 62 },    // Warm amber
            { h: 15, s: 55, l: 72 },    // Pale coral
            { h: 22, s: 68, l: 66 },    // Muted orange
        ];

        this.resize();
        this.initBlobs();
        this.animate();

        window.addEventListener('resize', () => this.resize());
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width * dpr;
        this.canvas.height = this.height * dpr;
        this.canvas.style.width = this.width + 'px';
        this.canvas.style.height = this.height + 'px';
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.scale(dpr, dpr);
    }

    initBlobs() {
        for (let i = 0; i < this.numBlobs; i++) {
            this.blobs.push({
                x: Math.random() * this.width,
                y: Math.random() * this.height,
                baseRadius: 250 + Math.random() * 300,
                vx: 0,
                vy: (Math.random() - 0.5) * 0.4, // Some rise, some fall
                wobbleOffset: Math.random() * Math.PI * 2,
                wobbleSpeed: 0.002 + Math.random() * 0.002,
                colorIndex: i % this.colors.length,
                colorShiftSpeed: 0.0003 + Math.random() * 0.0002,
                colorPhase: Math.random() * Math.PI * 2
            });
        }
    }

    getColor(blob, alpha = 1) {
        // Slowly shift between colors
        const phase = blob.colorPhase + this.time * blob.colorShiftSpeed;
        const idx1 = Math.floor(phase) % this.colors.length;
        const idx2 = (idx1 + 1) % this.colors.length;
        const t = phase % 1;

        const c1 = this.colors[idx1];
        const c2 = this.colors[idx2];

        const h = c1.h + (c2.h - c1.h) * t;
        const s = c1.s + (c2.s - c1.s) * t;
        const l = c1.l + (c2.l - c1.l) * t;

        return `hsla(${h}, ${s}%, ${l}%, ${alpha})`;
    }

    updateBlob(blob) {
        // Vertical drift
        blob.y += blob.vy;

        // Reverse direction at edges (smooth transition)
        if (blob.y < blob.baseRadius * 0.5) {
            blob.vy += 0.005;
        } else if (blob.y > this.height - blob.baseRadius * 0.5) {
            blob.vy -= 0.005;
        }

        // Dampen velocity
        blob.vy *= 0.999;

        // Clamp velocity
        blob.vy = Math.max(-0.5, Math.min(0.5, blob.vy));

        // Horizontal wobble
        const wobble = Math.sin(this.time * blob.wobbleSpeed + blob.wobbleOffset);
        blob.x += wobble * 0.3;

        // Keep in bounds horizontally
        if (blob.x < blob.baseRadius * 0.3) blob.x = blob.baseRadius * 0.3;
        if (blob.x > this.width - blob.baseRadius * 0.3) blob.x = this.width - blob.baseRadius * 0.3;
    }

    drawBlob(blob) {
        const ctx = this.ctx;

        // Calculate stretch based on velocity
        const stretch = 1 + Math.abs(blob.vy) * 0.3;
        const squash = 1 / Math.sqrt(stretch);

        const radiusX = blob.baseRadius * squash;
        const radiusY = blob.baseRadius * stretch;

        // Create radial gradient for inner glow, darker edges
        const gradient = ctx.createRadialGradient(
            blob.x, blob.y, 0,
            blob.x, blob.y, Math.max(radiusX, radiusY)
        );

        // Subtle opacity for gentle color wash
        gradient.addColorStop(0, this.getColor(blob, 0.4));
        gradient.addColorStop(0.3, this.getColor(blob, 0.3));
        gradient.addColorStop(0.6, this.getColor(blob, 0.15));
        gradient.addColorStop(1, this.getColor(blob, 0));

        ctx.save();
        ctx.translate(blob.x, blob.y);

        // Add slight rotation based on horizontal movement
        const wobble = Math.sin(this.time * blob.wobbleSpeed + blob.wobbleOffset);
        ctx.rotate(wobble * 0.05);

        ctx.beginPath();
        ctx.ellipse(0, 0, radiusX, radiusY, 0, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        ctx.restore();
    }

    draw() {
        // Warm peachy base - matches blob palette for seamless blending
        const bgGradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
        bgGradient.addColorStop(0, '#ffd4b8');
        bgGradient.addColorStop(0.5, '#ffc9a8');
        bgGradient.addColorStop(1, '#ffbe98');

        this.ctx.fillStyle = bgGradient;
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Heavy blur for seamless color blending
        this.ctx.filter = 'blur(80px)';

        // Update and draw all blobs
        for (const blob of this.blobs) {
            this.updateBlob(blob);
            this.drawBlob(blob);
        }

        // Reset filter
        this.ctx.filter = 'none';

        // Second pass - very subtle highlights
        this.ctx.filter = 'blur(60px)';
        for (const blob of this.blobs) {
            const ctx = this.ctx;
            const innerRadius = blob.baseRadius * 0.7;

            const gradient = ctx.createRadialGradient(
                blob.x, blob.y, 0,
                blob.x, blob.y, innerRadius
            );

            gradient.addColorStop(0, this.getColor(blob, 0.2));
            gradient.addColorStop(0.5, this.getColor(blob, 0.1));
            gradient.addColorStop(1, this.getColor(blob, 0));

            ctx.beginPath();
            ctx.arc(blob.x, blob.y, innerRadius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
        }

        this.ctx.filter = 'none';
    }

    animate() {
        this.time++;
        this.draw();
        requestAnimationFrame(() => this.animate());
    }
}

// Initialize lava lamp background
const lavaLamp = new LavaLamp(document.getElementById('lava-canvas'));

// ═══════════════════════════════════════════════════════════════════════════════
// CLOCK
// ═══════════════════════════════════════════════════════════════════════════════

function updateClock() {
    const now = new Date();
    let hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const period = hours >= 12 ? 'PM' : 'AM';

    hours = hours % 12 || 12;

    document.getElementById('clock').textContent = `${hours}:${minutes}`;
    document.getElementById('clock-period').textContent = period;
}

setInterval(updateClock, 1000);
updateClock();

// ═══════════════════════════════════════════════════════════════════════════════
// GOALS
// ═══════════════════════════════════════════════════════════════════════════════

function renderGoals() {
    const container = document.getElementById('goals-section');

    const sections = [
        { title: 'DAILY', items: CONFIG.daily },
        { title: 'MID-TERM', items: CONFIG.midTerm },
        { title: 'LONG-TERM', items: CONFIG.longTerm }
    ];

    container.innerHTML = sections.map(section => `
        <div class="goal-group">
            <h3>${section.title}</h3>
            ${section.items.map((item, idx) => `
                <div class="goal-item" data-section="${section.title}" data-index="${idx}">
                    <div class="goal-checkbox"></div>
                    <span class="goal-text">${item}</span>
                </div>
            `).join('')}
        </div>
    `).join('');

    container.querySelectorAll('.goal-item').forEach(item => {
        item.addEventListener('click', () => {
            item.classList.toggle('checked');
        });
    });
}

renderGoals();

// ═══════════════════════════════════════════════════════════════════════════════
// SCHEDULE
// ═══════════════════════════════════════════════════════════════════════════════

function renderSchedule() {
    const gridContainer = document.getElementById('time-grid');
    const eventsContainer = document.getElementById('schedule-events');

    const startHour = 5;
    const endHour = 24;
    let gridHTML = '';

    for (let hour = startHour; hour <= endHour; hour++) {
        for (let quarter = 0; quarter < 4; quarter++) {
            if (hour === endHour && quarter > 0) break;

            const showLabel = quarter === 0;
            const displayHour = hour % 12 || 12;
            const period = hour >= 12 ? 'PM' : 'AM';

            gridHTML += `
                <div class="time-slot">
                    <span class="time-label">${showLabel ? `${displayHour} ${period}` : ''}</span>
                    <div class="time-line" style="opacity: ${showLabel ? 0.18 : 0.06}"></div>
                </div>
            `;
        }
    }

    gridContainer.innerHTML = gridHTML;

    const slotHeight = 20;

    eventsContainer.innerHTML = CONFIG.schedule.map(event => {
        const [hours, minutes] = event.time.split(':').map(Number);
        const startSlot = (hours - startHour) * 4 + (minutes / 15);
        const durationSlots = event.duration / 15;

        const top = startSlot * slotHeight;
        const height = durationSlots * slotHeight - 4;

        return `
            <div class="schedule-event ${event.type}" style="top: ${top}px; height: ${height}px;">
                ${event.title}
            </div>
        `;
    }).join('');

    setTimeout(() => {
        const now = new Date();
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();

        if (currentHour >= startHour) {
            const currentSlot = (currentHour - startHour) * 4 + Math.floor(currentMinute / 15);
            const scrollTo = Math.max(0, (currentSlot - 4) * slotHeight);
            document.getElementById('schedule-scroll').scrollTop = scrollTo;
        }
    }, 100);
}

renderSchedule();

// ═══════════════════════════════════════════════════════════════════════════════
// TIMER
// ═══════════════════════════════════════════════════════════════════════════════

let timerInterval = null;
let timerRemaining = 0;
let timerPaused = false;

function renderTimerPresets() {
    const container = document.getElementById('timer-bar');

    container.innerHTML = CONFIG.timerPresets.map(minutes => `
        <button class="timer-preset" data-minutes="${minutes}">${minutes}</button>
    `).join('');

    container.querySelectorAll('.timer-preset').forEach(btn => {
        btn.addEventListener('click', () => {
            startTimer(parseInt(btn.dataset.minutes));
        });
    });
}

function startTimer(minutes) {
    timerRemaining = minutes * 60;
    timerPaused = false;
    updateTimerDisplay();

    document.getElementById('dashboard').classList.add('hidden');
    document.getElementById('timer-overlay').classList.add('active');
    document.getElementById('timer-pause').textContent = 'PAUSE';

    timerInterval = setInterval(() => {
        if (!timerPaused) {
            timerRemaining--;
            updateTimerDisplay();

            if (timerRemaining <= 0) {
                endTimer();
            }
        }
    }, 1000);
}

function updateTimerDisplay() {
    const minutes = Math.floor(timerRemaining / 60);
    const seconds = timerRemaining % 60;
    document.getElementById('timer-display').textContent =
        `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

function endTimer() {
    clearInterval(timerInterval);
    timerInterval = null;

    document.getElementById('dashboard').classList.remove('hidden');
    document.getElementById('timer-overlay').classList.remove('active');
}

document.getElementById('timer-pause').addEventListener('click', () => {
    timerPaused = !timerPaused;
    document.getElementById('timer-pause').textContent = timerPaused ? 'RESUME' : 'PAUSE';
});

document.getElementById('timer-stop').addEventListener('click', endTimer);

renderTimerPresets();

// ═══════════════════════════════════════════════════════════════════════════════
// DOTTED GLOBE WITH REAL GEOGRAPHIC DATA
// Uses Natural Earth land data via TopoJSON
// ═══════════════════════════════════════════════════════════════════════════════

// TopoJSON decoder (minimal implementation)
function decodeArc(topology, arc) {
    let x = 0, y = 0;
    return arc.map(([dx, dy]) => {
        x += dx;
        y += dy;
        return [
            x * topology.transform.scale[0] + topology.transform.translate[0],
            y * topology.transform.scale[1] + topology.transform.translate[1]
        ];
    });
}

function decodeArcs(topology, arcs) {
    return arcs.map(index => {
        const arc = topology.arcs[index < 0 ? ~index : index];
        const decoded = decodeArc(topology, arc);
        return index < 0 ? decoded.reverse() : decoded;
    }).flat();
}

function topoFeature(topology, object) {
    if (object.type === 'GeometryCollection') {
        return {
            type: 'FeatureCollection',
            features: object.geometries.map(geom => topoFeature(topology, geom))
        };
    }

    const coords = [];

    if (object.type === 'Polygon') {
        object.arcs.forEach(ring => {
            coords.push(decodeArcs(topology, ring));
        });
    } else if (object.type === 'MultiPolygon') {
        object.arcs.forEach(polygon => {
            const polyCoords = [];
            polygon.forEach(ring => {
                polyCoords.push(decodeArcs(topology, ring));
            });
            coords.push(polyCoords);
        });
    }

    return { type: 'Feature', geometry: { type: object.type, coordinates: coords } };
}

// Point in polygon test using ray casting
function pointInPolygon(point, polygon) {
    const [x, y] = point;
    let inside = false;

    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const [xi, yi] = polygon[i];
        const [xj, yj] = polygon[j];

        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
            inside = !inside;
        }
    }

    return inside;
}

// Check if point is on land
function createLandChecker(landFeature) {
    const polygons = [];

    function extractPolygons(geometry) {
        if (geometry.type === 'Polygon') {
            polygons.push(geometry.coordinates[0]); // Outer ring only
        } else if (geometry.type === 'MultiPolygon') {
            geometry.coordinates.forEach(poly => {
                polygons.push(poly[0]); // Outer ring of each polygon
            });
        }
    }

    if (landFeature.type === 'FeatureCollection') {
        landFeature.features.forEach(f => extractPolygons(f.geometry));
    } else if (landFeature.geometry) {
        extractPolygons(landFeature.geometry);
    }

    return function isLand(lon, lat) {
        for (const poly of polygons) {
            if (pointInPolygon([lon, lat], poly)) {
                return true;
            }
        }
        return false;
    };
}

class DottedGlobe {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.rotation = options.initialRotation || 1.5;
        this.rotationSpeed = options.rotationSpeed || 0.001;
        this.dotColor = options.dotColor || '#2d2d2d';
        this.highlightColor = options.highlightColor || '#e67635';
        this.highlightLocation = options.highlightLocation || null;
        this.size = options.size || 400;
        this.dotSpacing = options.dotSpacing || 2.5;
        this.landPoints = [];
        this.isLand = null;
        this.ready = false;

        this.resize();
    }

    async loadLandData() {
        try {
            const response = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json');
            const topology = await response.json();
            const landFeature = topoFeature(topology, topology.objects.land);
            this.isLand = createLandChecker(landFeature);
            this.generateLandPoints();
            this.ready = true;

            // Hide loading indicator
            const loading = document.getElementById('globe-loading');
            if (loading) loading.style.display = 'none';

            this.animate();
        } catch (error) {
            console.error('Failed to load land data:', error);
            // Fallback to simple globe
            this.generateFallbackPoints();
            this.ready = true;
            this.animate();
        }
    }

    generateLandPoints() {
        this.landPoints = [];

        for (let lat = -85; lat <= 85; lat += this.dotSpacing) {
            const latRad = Math.abs(lat) * Math.PI / 180;
            const lonSpacing = this.dotSpacing / Math.max(0.3, Math.cos(latRad));

            for (let lon = -180; lon < 180; lon += lonSpacing) {
                if (this.isLand && this.isLand(lon, lat)) {
                    this.landPoints.push({ lat, lon });
                }
            }
        }
    }

    generateFallbackPoints() {
        // Simple fallback if fetch fails
        this.landPoints = [];
        for (let lat = -60; lat <= 70; lat += 4) {
            for (let lon = -180; lon < 180; lon += 4) {
                if (Math.random() > 0.7) {
                    this.landPoints.push({ lat, lon });
                }
            }
        }
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = this.size * dpr;
        this.canvas.height = this.size * dpr;
        this.canvas.style.width = this.size + 'px';
        this.canvas.style.height = this.size + 'px';
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.scale(dpr, dpr);

        this.centerX = this.size / 2;
        this.centerY = this.size / 2;
        this.radius = this.size * 0.45;
    }

    latLonToXYZ(lat, lon) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);

        return {
            x: -Math.sin(phi) * Math.cos(theta),
            y: Math.cos(phi),
            z: Math.sin(phi) * Math.sin(theta)
        };
    }

    rotateY(point, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return {
            x: point.x * cos - point.z * sin,
            y: point.y,
            z: point.x * sin + point.z * cos
        };
    }

    project(point) {
        return {
            x: this.centerX + point.x * this.radius,
            y: this.centerY - point.y * this.radius,
            z: point.z
        };
    }

    draw() {
        this.ctx.clearRect(0, 0, this.size, this.size);

        const dots = [];
        const dotRadius = this.size / 200;

        // Process land points
        this.landPoints.forEach(({ lat, lon }) => {
            const point = this.latLonToXYZ(lat, lon);
            const rotated = this.rotateY(point, this.rotation);

            if (rotated.z > -0.15) {
                const projected = this.project(rotated);
                dots.push({
                    x: projected.x,
                    y: projected.y,
                    z: rotated.z,
                    isHighlight: false
                });
            }
        });

        // Add highlight location
        if (this.highlightLocation) {
            const point = this.latLonToXYZ(this.highlightLocation.lat, this.highlightLocation.lon);
            const rotated = this.rotateY(point, this.rotation);

            if (rotated.z > -0.15) {
                const projected = this.project(rotated);
                dots.push({
                    x: projected.x,
                    y: projected.y,
                    z: rotated.z,
                    isHighlight: true
                });
            }
        }

        // Sort by z (back to front)
        dots.sort((a, b) => a.z - b.z);

        // Draw dots
        dots.forEach(dot => {
            const depthOpacity = Math.max(0.12, (dot.z + 0.15) / 1.15);

            if (dot.isHighlight) {
                const glowRadius = dotRadius * 5;

                // Outer glow
                const gradient = this.ctx.createRadialGradient(
                    dot.x, dot.y, 0,
                    dot.x, dot.y, glowRadius
                );
                gradient.addColorStop(0, this.highlightColor);
                gradient.addColorStop(0.3, this.highlightColor + 'cc');
                gradient.addColorStop(0.6, this.highlightColor + '44');
                gradient.addColorStop(1, 'transparent');

                this.ctx.beginPath();
                this.ctx.arc(dot.x, dot.y, glowRadius, 0, Math.PI * 2);
                this.ctx.fillStyle = gradient;
                this.ctx.fill();

                // Inner solid dot
                this.ctx.beginPath();
                this.ctx.arc(dot.x, dot.y, dotRadius * 1.8, 0, Math.PI * 2);
                this.ctx.fillStyle = this.highlightColor;
                this.ctx.fill();
            } else {
                const alpha = Math.floor(depthOpacity * 255).toString(16).padStart(2, '0');
                this.ctx.beginPath();
                this.ctx.arc(dot.x, dot.y, dotRadius, 0, Math.PI * 2);
                this.ctx.fillStyle = this.dotColor + alpha;
                this.ctx.fill();
            }
        });
    }

    animate() {
        if (!this.ready) return;
        this.rotation += this.rotationSpeed;
        this.draw();
        requestAnimationFrame(() => this.animate());
    }
}

// Initialize globes
const mainGlobe = new DottedGlobe(document.getElementById('globe-canvas'), {
    size: 450,
    highlightLocation: CONFIG.location,
    rotationSpeed: 0.001,
    dotSpacing: 2.0,
    dotColor: '#2d2d2d',
    highlightColor: '#e67635',
    initialRotation: 1.4
});

const timerGlobe = new DottedGlobe(document.getElementById('timer-globe-canvas'), {
    size: 650,
    highlightLocation: CONFIG.location,
    rotationSpeed: 0.0006,
    dotSpacing: 2.5,
    dotColor: '#4a4a4a',
    highlightColor: '#e67635',
    initialRotation: 1.4
});

// Load land data for both globes
Promise.all([
    mainGlobe.loadLandData(),
    timerGlobe.loadLandData()
]);

// Handle window resize
window.addEventListener('resize', () => {
    mainGlobe.resize();
    timerGlobe.resize();
});
</script>

</body>
</html>
